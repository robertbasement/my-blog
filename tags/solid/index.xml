<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SOLID on RobertBasement</title>
    <link>https://robertbasement.github.io/my-blog/tags/solid/</link>
    <description>Recent content in SOLID on RobertBasement</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 29 Nov 2021 16:10:40 +0800</lastBuildDate>
    <atom:link href="https://robertbasement.github.io/my-blog/tags/solid/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SOLID、SoC</title>
      <link>https://robertbasement.github.io/my-blog/posts/post/2021/2021129_solid%E5%8E%9F%E5%89%87.md/</link>
      <pubDate>Mon, 29 Nov 2021 16:10:40 +0800</pubDate>
      <guid>https://robertbasement.github.io/my-blog/posts/post/2021/2021129_solid%E5%8E%9F%E5%89%87.md/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;h2 id=&#34;solid原則&#34;&gt;SOLID原則&lt;/h2&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;single-responsibility-principle-單一功能原則&#34;&gt;Single responsibility principle 單一功能原則&lt;/h3&gt;&#xA;&lt;p&gt;認為一個class就應該只有一個任務要做，不做其他任務以外的事情，過去是很多不同的需求都用同一個Service，單一功能原則則是提供各種不同的Use Case給各個需求。&#xA;&lt;figure &#xD;&#xA;&#x9;&gt;&#xD;&#xA;&#x9;&lt;a href=&#34;https://robertbasement.github.io/my-blog/images/20211129_SOLID_SoC_SRP.jpg&#34; &gt;&#xD;&#xA;&#x9;&#x9;&lt;img src=&#34;https://robertbasement.github.io/my-blog/images/20211129_SOLID_SoC_SRP.jpg&#34;&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;loading=&#34;lazy&#34;&#xD;&#xA;&#x9;&#x9;&#x9;alt=&#34;SRP示意圖&#34;&gt;&#xD;&#xA;&#x9;&lt;/a&gt;&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;&lt;figcaption&gt;SRP示意圖&lt;/figcaption&gt;&#xD;&#xA;&#x9;&#xD;&#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;open-closed-principle-開閉原則&#34;&gt;Open/ closed principle 開閉原則&lt;/h3&gt;&#xA;&lt;p&gt;一個class或Function對於他的擴展是開放的，但是對於修改是封閉的，意思就是不改變他的行為，但是可以增加新的功能。&#xA;就像是電動理髮刀，可以換上各種不同的刀頭(擴展)，但是機身本體是不能修改的(封閉)。&lt;/p&gt;&#xA;&lt;h3 id=&#34;liskov-substitution-principle-里氏替換原則&#34;&gt;Liskov substitution principle 里氏替換原則&lt;/h3&gt;&#xA;&lt;p&gt;程式中的物件應該是可以在不改變正確性的前提下被他的子類所替換的概念，我們在使用「繼承」時，重要的是重複使用 (reuse) 已經寫好的行為，而不是將所有繼承的行為全部覆蓋。&lt;/p&gt;&#xA;&lt;h3 id=&#34;interface-segregation-principle-介面隔離原則&#34;&gt;Interface segregation principle 介面隔離原則&lt;/h3&gt;&#xA;&lt;p&gt;很多個客製化的interface比一個通用的interface還要來得更好管理，例如一個政客interface有提出政見()、拜票()、努力工作()，但事實上不是每一個政客都想實作努力工作XD，所以應該方別建兩個interface，政客介面:提出政見()、拜票()與工作介面:努力工作()。&lt;/p&gt;&#xA;&lt;h3 id=&#34;dependency-inversion-principle-依賴反轉原則&#34;&gt;Dependency inversion principle 依賴反轉原則&lt;/h3&gt;&#xA;&lt;p&gt;各個class之間的相依性應該越低越好，上層的class不該依賴下層的class&#xA;&lt;figure &#xD;&#xA;&#x9;&gt;&#xD;&#xA;&#x9;&lt;a href=&#34;https://robertbasement.github.io/my-blog/images/20211129_SOLID_SoC_DI.jpg&#34; &gt;&#xD;&#xA;&#x9;&#x9;&lt;img src=&#34;https://robertbasement.github.io/my-blog/images/20211129_SOLID_SoC_DI.jpg&#34;&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;loading=&#34;lazy&#34;&#xD;&#xA;&#x9;&#x9;&#x9;alt=&#34;DIP示意圖&#34;&gt;&#xD;&#xA;&#x9;&lt;/a&gt;&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;&lt;figcaption&gt;DIP示意圖&lt;/figcaption&gt;&#xD;&#xA;&#x9;&#xD;&#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;h2 id=&#34;socseparation-of-concerns-關注點分離&#34;&gt;SoC(Separation of concerns) 關注點分離&lt;/h2&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;關注點分離表示，以前端的例子來說，在過去我們是以「關注技術」的方式來分離成HTML、CSS、JavaScript，現今主流框架Vue則是採用「關注元件」的方式來分離，每一個Component都有各自的HTML、CSS、JavaScript。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;h2 id=&#34;參考&#34;&gt;參考&lt;/h2&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/SOLID_%28%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xD;&#xA;    &gt;https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)&lt;/a&gt;&#xA;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@f40507777/%E9%96%8B%E6%94%BE%E5%B0%81%E9%96%89%E5%8E%9F%E5%89%87-open-closed-principle-31d61f9d37a5&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xD;&#xA;    &gt;https://medium.com/@f40507777/%E9%96%8B%E6%94%BE%E5%B0%81%E9%96%89%E5%8E%9F%E5%89%87-open-closed-principle-31d61f9d37a5&lt;/a&gt;&#xA;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/%E7%AC%AC-10-%E7%AB%A0-%E9%A1%9E%E5%88%A5-clean-code-1c7898d11cd7&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xD;&#xA;    &gt;https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/%E7%AC%AC-10-%E7%AB%A0-%E9%A1%9E%E5%88%A5-clean-code-1c7898d11cd7&lt;/a&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
